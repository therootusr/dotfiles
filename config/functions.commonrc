# +10, -31 -> not int
function is_unsigned_int () {
    case "$1" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

function gx() {
  src=$1
  shift
  g++ -o ${src}.out $@ $src && ./${src}.out
}


function g1() {
  #g++ --std=c++11 -o $1.out $1 && ./$1.out
  gx $@ --std=c++11
}

function g4() {
  #g++ --std=c++14 -o $1.out $1 && ./$1.out
  gx $@ --std=c++14
}

function g7() {
  #g++ --std=c++17 -o $1.out $1 && ./$1.out
  gx $@ --std=c++17
}

function g2b() {
  #g++ --std=c++23 -o $1.out $1 && ./$1.out
  gx $@ --std=c++2b
}

function g20() {
  #g++ --std=c++20 -o $1.out $1 && ./$1.out
  gx $@ --std=c++20
}

function fixup() {
  git reset --soft HEAD~$1
  git commit -v -a --amend --no-edit
}

# works with zsh; doesn't work with bash
function clang-format-git() {
  # is_git=$(git diff $1 &>/dev/null)
  # if [ $? -ne 0 ]; then
  #   echo "[ERROR] not a git repository"
  # fi

  git diff -U1 -- $1 | while read line ; do
    if [[ $line =~ "^@@.*\+([0-9]+),([0-9]+).*@@" ]];then
      from=$(($match[1] + 1))
      to=$(($match[1] + $match[2] - 2))
      clang-format -i --style=file --fallback-style=google --lines=$from:$to $1
    fi
  done
}

gpip(){
   PIP_REQUIRE_VIRTUALENV="0" pip3 "$@"
}

# Use command-t instead.
# Use alias 'gv' instead
function gvim() {
    file_path=$(git ls-files | grep -m1 -w $1)
    if [ -z $file_path ]; then
        echo "file not found"
        return 16
    fi

    echo $file_path
    vim $file_path
}

function swap() {
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE && mv "$2" "$1" && mv $TMPFILE "$2"
}

function tailRemoteFile() {
    if [ -z $1 ] || [ -z $2 ]; then
        echo "ERROR: Remote or Remote file path not provided"
        return 1
    fi

    log_file_name=$(basename $2)-${1/#*@/}
    if [ -e "$USR_LOG_DIR/$log_file_name" ]; then
        i=1
        while [ -e "$USR_LOG_DIR/$log_file_name-$i" ]; do
            let i++
        done
        log_file_name=$log_file_name-$i
    fi

    echo "cmd: ssh -o stricthostkeychecking=no $1 \"tail -F $2\" 2>&1 > $USR_LOG_DIR/$log_file_name"
    ln -f -v -s $USR_LOG_DIR/$log_file_name $USR_LOG_DIR/$(basename $2)
    ssh -o stricthostkeychecking=no $1 "tail -F $2" 2>&1 > $USR_LOG_DIR/$log_file_name
}

# Files receiving output from tailRemoteFile in logs dir (or a
# simple tail -F over ssh for that matter).
function get_remote_tail_files() {
  for pid in `pgrep -f "ssh.*tail.*-F"`
  do
    lsof -p $pid | grep "[^ ]*""$USR_LOG_DIR""[^ ]*" -o
  done
}

# Compliments tailRemoteFile (and "ssh -F" in general).
# All log files in $USR_LOG_DIR matching the regex specified by $1
# will be tailed.
# Optionally specify a filter regex in $2 to filter tail output.
# $3 is grep options for regex in $2.
function tailLocalFile() {
  if [ -z $1 ]; then
    echo "ERROR: Please provide regex to match files to be tailed as" \
         "the first argument."
    return 1
  fi

  filter_tail_out=""
  if [ "$2" != "" ]; then
    filter_tail_out=" | egrep $3 '(^=|$2)'"
  fi

  filepaths=`get_remote_tail_files | grep $1`
  echo "INFO: tail -F:\n$filepaths"
  echo ""
  # syntax issues without `echo | tr`
  /bin/sh -c "tail -F `echo $filepaths | tr '\n' ' '` $filter_tail_out"
}

# For macOS
function mac_watch() {
    local sleep_dur=$1
    num_reg=^[0-9]+([.][0-9]+)?$
    if ! [[ $1 =~ $num_reg ]] ; then
       echo "Incorrect sleep duration: $1" >&2
       return 1
    fi
    shift
    while :; do clear; date; echo; $@; sleep $sleep_dur; done
}

function parse_ssl_cert() {
  tmpfile=`mktemp`
  echo $tmpfile 1>&2
  echo ""
  #echo $1 | sed 's/\\n/\
#/g' | sed '$d' > $tmpfile
  # echo auto replaces '\n' with actual newlines
  echo $1 > $tmpfile

openssl x509 -in $tmpfile -text
}

function sshp {
  expect $HOME/workspace/misc/scripts/ssh_pass.exp $@
}

# DEPRECATED: use "$ (cmd) $!" to disown (portable?)
# Following errors seen when running just nohup zsh -ci '...':
#   - suspended (tty output) (stty -tostop didn't help)
#   - zsh: can't set tty pgrp: interrupt
#   - $HOME/.oh-my-zsh/oh-my-zsh.sh:24: bad tcgets: inappropriate ioctl for device
# USAGE: nhup "cmd/func/alias --arg1 val1 --arg2 'val2.1 val2.2'"
function nhup {
  # $* doesn't properly expand --arg 'val1 val2'
  # nohup bash -ci "zsh -ci '$*'" 2>&1 >~/.nohup.out &
  nohup bash -ci "zsh -ci '$@'" 2>&1 >~/.nohup.out &
}

function wait_for_remote_proc {
  local -r remote=$1
  local -r proc=$2
  # "tail -1" is suboptimal
  if is_unsigned_int $proc; then
    local -r notif=`ssh $remote "ps -p $proc -o cmd | tail -1"`
    local -r wait_for_cmd="ps -p $proc"
  else
    local -r notif=`ssh $remote "ps -o pid,cmd ax | grep $proc | grep -v \"grep $proc\" | tail -1"`
    local -r pid=`echo $notif | cut -d' ' -f1`
    # pidof
    local -r wait_for_cmd="ps -p $pid"
  fi

  # TODO: what if pid was reused
  ssh -q $remote << EOD
    while $wait_for_cmd >/dev/null
    do
      sleep 2
    done
EOD
    osascript -e "display notification \"$notif\" with title \" cmd complete\" sound name \"\""
}

function echo_trlf_cp {
  echo -n $1 | tr '\n' ' ' | pbcopy
}

function decrypt_b64_rsa_oaep_sha256 {
  key_file=$1
  in_file=$2
  openssl pkeyutl -decrypt -inkey $key_file -in <(cat $in_file | base64 -D) -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha256
}

function decrypt_rsa_oaep_sha256 {
  key_file=$1
  in_file=$2
  openssl pkeyutl -decrypt -inkey $key_file -in $in_file -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha256
}

function f_dc {
  cd $(dirname $(find . -iname "compose.yaml"))
  docker compose $@
  cd - > /dev/null
}

function f_generate_ecdsa {
  KEY_FILE=$1
  openssl ecparam -genkey -name secp521r1 -out $KEY_FILE
  # extract the public key
  ssh-keygen -y -f $KEY_FILE > ${KEY_FILE}.pub
}

function f_rsa_pem_to_pkix_pub {
  # PUBLIC_KEY_PEM needs to be in PEM format:
    # ssh-keygen -f <pub-key>/<private-key> -e -m PEM
  PUBLIC_KEY_PEM=$1
  OUTPUT_FILE=$2
  openssl rsa -in $PUBLIC_KEY_PEM -pubin -RSAPublicKey_in -outform PEM -out $OUTPUT_FILE
}

function f_git_staged_clang_format {
  file=$1

  # Skip non cpp files
  if ! [[ $file =~ ".*\.cc" || $file =~ ".*\.h" ]];
  then
    echo "WARNING: Skipping non-cpp file: $file" 1>&2
    continue
  fi

  git diff -U1 --cached -- $file | while read line
  do
      if [[ $line =~ "^@@.*\+([0-9]+),([0-9]+).*@@" ]];
      then
          from=$(($match[1] + 1))
          to=$(($match[1] + $match[2] - 1))
          echo "INFO: Running clang-format on $file:$from:$to" 1>&2
          clang-format -i --style=file --fallback-style=google --lines=$from:$to $file
      fi
  done
}

function f_git_staged_clang_format_all {
  for changed_file in `git diff --name-only --cached`; do
    f_git_staged_clang_format $changed_file
  done
}

# ws: whitespace
function ws_trim {
  sed -i '' -e 's/^[[:space:]]*$//g' -e 's/[[:space:]]*$//g' $1
}

# ws: whitespace
function gws_trim {
  sed -i '' -e 's/^[[:space:]]*$//g' -e 's/[[:space:]]*$//g' $(git diff --name-only --cached)
}

# prints max mem used in kb
function xtime {
  /usr/bin/time -f '%Uu %Ss %er %MkB %C' "$@"
}

function test_block_dev_perf {
  local block_dev=$1
  # sync # exec `sync`?
  hdparm -t $block_dev
}

# what about checking fs metadata perf?
function test_disk_perf {
  local fio_filepath=$1
  fio --name=randrw4k --rw=randrw --bs=4k --iodepth=32 --size=2G --runtime=30 --time_based --ioengine=io_uring --direct=1 --filename=$fio_filepath --group_reporting
}

function tfch {
  local target_dir=$1
  shift
  terraform -chdir=$target_dir $@
}

# kdeb my-pod-0                         # Uses current namespace, /bin/bash
# kdeb some-pod my-namespace            # Specify namespace
# kdeb custom-pod my-namespace /bin/sh  # Custom shell
function kdeb() {
  local pod=${1:?Usage: kdeb <pod-name> [namespace] [shell]}
  local ns=${2:-$(kubectl config view --minify -o jsonpath='{..namespace}' 2>/dev/null || echo default)}
  local shell=${3:-/bin/bash}
  local image=$(kubectl get pod "$pod" -n "$ns" -o jsonpath='{.spec.containers[0].image}' 2>/dev/null)
  [ -z "$image" ] && { echo "Error: Could not get image for pod $pod in namespace $ns" >&2; return 1 }
  kubectl run "debug-${pod}" \
    --image="$image" --rm -it --restart=Never -n "$ns" \
    --overrides="{\"spec\":{\"containers\":[{\"name\":\"debug-${pod}\",\"image\":\"${image}\",\"command\":[\"${shell}\"],\"stdin\":true,\"tty\":true}]}}"
}

# May wanna "Reload Window" afterwards
function import_cursor_rules() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "FATAL: not a git repo"
    return 1
  fi
  cd "$(git rev-parse --show-toplevel)"

  local kMyCursorRulesDir="${HOME}/workspace/personal/app-configs/cursor/rules"
  readonly kMyCursorRulesDir

  if [  -e ".cursor/rules" ]; then
    mkdir -p ".cursor/rules/external"
    # Cursor refuses to recognize symlinks within .cursor/rules/
    cp -vr "${kMyCursorRulesDir}"/. ".cursor/rules/external/"
  else
    mkdir -pv .cursor
    ln -vs "${kMyCursorRulesDir}" .cursor/
  fi
}

function import_obsidian_carbon_snippet() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "FATAL: not a git repo"
    return 1
  fi
  cd "$(git rev-parse --show-toplevel)"

  local kObsidianCarbonCssFile="${HOME}/workspace/personal/app-configs/obsidian/snippets/obsidian-carbon.css"
  readonly kMyCursorRulesDir

  local obsidianSnippetsDir=".obsidian/snippets"
  local relativeTargetPath=".obsidian/snippets/obsidian-carbon.css"
  readonly obsidianSnippetsDir relativeTargetPath

  mkdir -pv $obsidianSnippetsDir
  if [  -e "$relativeTargetPath" ]; then
    # ln --backup=<> needn't work on mac
    mv -v "$relativeTargetPath" "$relativeTargetPath.$(date | tr ' ' '-d' | tr -s '-')"
  fi

  ln -fv "$kObsidianCarbonCssFile" "$relativeTargetPath"
}

# Debug a Kubernetes node: run an ephemeral privileged shell on the node.
# Usage: kdebn [NODE_NAME] [IMAGE]
#   NODE_NAME  optional; if omitted, chosen interactively via fzf or first node
#   IMAGE      optional; default busybox (use ubuntu, alpine, etc. for more tools)
function kdebn() {
  local node="${1:-}"
  local image="${2:-busybox}"
  if [[ -z "$node" ]]; then
    echo "kdebn: no node selected" >&2
    echo "Usage: kdebn [NODE_NAME] [IMAGE]" >&2
    return 1
  fi
  echo "Debugging node: $node (image: $image). Exit shell when done." >&2
  kubectl debug "node/$node" -it --image="$image" -- chroot /host /bin/sh
  # NO 'kubectl debug --rm': enhance to auto-delete the pod? Needs to perfect, can't delete any other pod
}

# Symmetric diff of file contents (by SHA256). Ignores paths/filenames; prints paths per tree.
function diff_tree_content() {
  local d1 d2 t1f t2f o1 o2
  d1="$(realpath $1)"
  d2="$(realpath $2)"
  t1f=$(mktemp) t2f=$(mktemp) o1=$(mktemp) o2=$(mktemp)
  (cd "$d1" && find . -type d -name .git -prune -o -type f -exec sha256sum {} + 2>/dev/null) | sort -k1,1 > "$t1f"
  (cd "$d2" && find . -type d -name .git -prune -o -type f -exec sha256sum {} + 2>/dev/null) | sort -k1,1 > "$t2f"
  comm -23 <(cut -d' ' -f1 "$t1f" | sort -u) <(cut -d' ' -f1 "$t2f" | sort -u) > "$o1"
  comm -13 <(cut -d' ' -f1 "$t1f" | sort -u) <(cut -d' ' -f1 "$t2f" | sort -u) > "$o2"
  echo "Only in $d1:"
  awk 'NR==FNR{a[$1];next} $1 in a {sub(/^[^ ]+  \*?/,""); print "  " $0}' "$o1" "$t1f"
  echo "Only in $d2:"
  awk 'NR==FNR{a[$1];next} $1 in a {sub(/^[^ ]+  \*?/,""); print "  " $0}' "$o2" "$t2f"
  /usr/bin/rm -f "$t1f" "$t2f" "$o1" "$o2"
}

# Symmetric diff by (basename, content). Same name + same content = match.
function diff_tree_name() {
  local d1 d2 t1 t2
  d1="$(realpath $1)" d2="$(realpath $2)"
  t1=$(mktemp) t2=$(mktemp)
  (cd "$d1" && find . -type d -name .git -prune -o -type f -exec sh -c 'for f; do printf "%s\t%s\n" "$(basename "$f")" "$(sha256sum < "$f" | awk "{print \$1}")"; done' _ {} + 2>/dev/null) | sort -u > "$t1"
  (cd "$d2" && find . -type d -name .git -prune -o -type f -exec sh -c 'for f; do printf "%s\t%s\n" "$(basename "$f")" "$(sha256sum < "$f" | awk "{print \$1}")"; done' _ {} + 2>/dev/null) | sort -u > "$t2"
  echo "Only in $d1 (name+sha256sum):"
  comm -23 "$t1" "$t2"
  echo "Only in $d2 (name+sha256sum):"
  comm -13 "$t1" "$t2"
  /usr/bin/rm -f "$t1" "$t2"
}

# Copy a range of commits from one repo to another and reset author (keep dates).
# Usage: git_copy_commits_to_repo <source-dir> <target-dir> <sha|sha1..sha2>
function git_cp_commits() {
  local src="$1" tgt="$2" rev="$3" range old_head
  [[ -z "$src" || -z "$tgt" || -z "$rev" ]] && { echo "Usage: git_copy_commits_to_repo <source-dir> <target-dir> <sha|sha1..sha2>" >&2; return 1; }
  [[ ! -d "$src/.git" || ! -d "$tgt/.git" ]] && { echo "Source and target must be git repos." >&2; return 1; }
  if [[ "$rev" == *..* ]]; then range="$rev"; else range="${rev}^..${rev}"; fi
  old_head=$(git -C "$tgt" rev-parse HEAD 2>/dev/null) || true
  git -C "$src" format-patch "$range" --stdout | git -C "$tgt" am
  (cd "$tgt" && git rebase -r "${old_head:---root}" --exec 'author_date="$(git log -1 HEAD --pretty=format:"%aI")" && git commit --amend --no-edit --reset-author --date="$author_date"')
}
